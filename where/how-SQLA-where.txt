# check where and how parameters may be used in CYPHER

how SQL::Abstract where works

Returning sql:
- lots of placeholders and bind lists ($sql, @bind)
-- apply the following to sql and bind list for consistency with rest of code
- _convert() - apply a conversion function to the arg (like upper() lower())
- _bindtype() - positional list of values, or a hash of column => value.

-- how to manage named parameters?


Initial top level call : $s->where($where)
- keeps track of all values, inserts placeholders and returns an array of
  of values along with SQL
  
- where() wraps _recurse_where($where)

- $where is interpreted depending on its type:
-- _recurse_where calls one of
   _where_ARRAYREF : input array is considered as pairs of elements (lhs => rhs)
   - for each pair ($lhs => $rhs), $rhs is handled by a _SWITCH_refkind dispatch
   _where_ARRAYREFREF : input array is literal SQL plus a bind value array (if present)
   _where_HASHREF : lots of special stuff happens here
   - $s->{_nested_func_lhs} is checked to see if at top level or deeper
   _where_SCALAR : literal SQL (at top level)
   _where_SCALARREF : literal SQL (at top level)


utility function _SWITCH_refkind($thing, $hash_of_REFKIND_to_coderefs)
- calls coderef (in 2nd arg) corresponding to the ref kind of $thing, with
  $thing as argument
- these are closures; sub {}s generally set $sql and @bind
- looks like a kludge because the _where_refkinds don't handle all
  possible events

_where_hashpair_ARRAYREF :
- factory version takes { $k => \@v } and distributes $k over @v (i.e.,
  creates an array of hashpairs [ { $k => $v[0] }, {$k => $v[1], ... ])
  (if first elt of @v is -and or -or, distributes this over rest of @v)
- this is where we need special beh. for list-domain functions/expressions 

_where_hashpair_HASHREF : lots more special stuff happens here
- input is { $k => \%v }
- $s->{_nested_func_lhs} is set _only_ here
-- if set here, is the key of the hashpair ($k)
- note that it calls itself recursively to handle hashref values of -and and -or
- special ops handled only here
- unary ops handled only here
- all special beh. handled here (most as "built-in" special ops)

_where_hashpair_SCALARREF
_where_hashpair_ARRAYREFREF
_where_hashpair_SCALAR
_where_hashpair_UNDEF

special behaviors:
_where_unary_op
_where_op_ANDOR
_where_op_NEST
_where_op_BOOL
_where_op_IDENT
_where_op_VALUE
_where_field_IS
_where_field_op_ARRAYREF **
_where_field_BETWEEN
_where_field_IN


Ok, this design is all kludge.

Need a true spec (in a table) for the construction behavior based on, say
(clause or other context, operator, [argument types]):
consider all possible combos

- unary operators without parens
- unary operators with parens ("functions")
- distributable operators / infix operators (include AND, OR)
- binary operators (including comparisons?)
- special syntax constructs (BETWEEN)

Throw when no handler is defined for a given combo.

- expression behaviors vs. statement (clause) behaviors

- shortcuts (like assuming the equality operator, assuming -and with
  hashes and -or with arrays) should be preprocessed? I.e., put the
  initial Perl data structure into a canonical form, then render as
  SQL.

- handle edge cases in isolated routines (if possible) rather than in
  the middle of the main code

- single function to handle any generic/default behavior (how to treat
  dashed operators not specified elsewhere)

Add finished clauses to a stack of some kind, and construct the
statement in a central place.

Need a true dispatch table that isolates the specification of actions
based on a set of parameters like (operator, argument type)

Need to see the perl expression as a syntax tree and do the right
thing, correctly within a simple recursion. Depth first and construct
clauses naturally.


Codify the current beh of SQL::Abstract

note: any 'val' can be replaced with \['literal SQL'] or
  \['literal SQL with placeholders', $bindval]

{ col1 => 'val1', col2 => 'val2' } : col1 = ? AND col2 = 2, ('val1','val2)

{ col => ['val1', 'val2'] } : col = ? OR col = ?, ('val1', 'val2')

{ col => undef } : col IS NULL ( a postfix op)

{ col => { '!=' => undef } } : col IS NOT NULL ( a postfix op)

{ col => { '!=' => 'val' } } : col != ?, ('val')

{ col => { '!=' => [ 'val1', 'val2' ] } } : col != ? AND col != ?, ('val1','val2;)

note:
{ col => { '=' => [ 'val1', 'val2' ] } } and
{ col => ['val1','val2'] } are equivalent : col = ? OR col = ?

{ col => { -op1 => 'val1', -op2 => 'val2' } } (joined with AND) :
  col OP1 ? AND col OP2 ?, ('val1', 'val2')

{ col => [ {-op1 => 'val1'}, {-op2 => 'val2'} ] }  (joined with OR)
  col OP1 ? OR col OP2 ?, ('val1', 'val2')

{ col => [ -and => {-op1 => 'val1'}, {-op2 => 'val2'} ] } (joined with AND)
which allows
{ col => [ -and => {-op => 'val1'}, {-op => 'val2'} ] }
  col OP ? AND col OP ?, ('val1','val2')


{ col => { -op => [ 'arg1', 'arg2' ] } } (-op could be -in,
      	       	    	    	       	  'arg1','arg2' returned as bind values)

 col OP (?, ?), ('arg1', 'arg2') (for IN, anyway)

-ident : mark arg as an identifier (i.e., don't replace it with placeholder
-value : mark arg as a value (e.g., treat arrayref arg as an array argument,
 don't distribute the (OR) function over the arrayref elements)

{ col1 => { -ident => 'col2' } ) : col1 = col2
{ col => { -value => ['val1', 'val2'] } } : col = ? , ( ['val1','val2'])
 ( not: col = ? AND/OR col = ?, ( 'val1', 'val2' ) )

Canonical expressions:

{ col => [ -infix => { -op1 => 'val1' }, { -op2 => 'val2'} ] }

{ col => ['val1', 'val2'] } equiv

{ col => [ -or => { '=' => 'val1' }, { '=' => 'val2' } ] }

{ col => { '=' => ['val1', 'val2'] } } equiv

{ col => [ -or => { '=' => 'val1'}, { '=' => 'val2'}] }

{ col1 => 'val1', col2 => 'val2' } equiv

[ -or => { col1 => { '=' => 'val1'} }, { col2 => {'=' => 'val2'} } ]

really, it's like lisp.
rpn

{ -extract => [ x, ['a','b','c'], { 'x.name' => { '!=' => 'bill' } } ] }
extract( x IN [a,b,c] | x.name != 'bill' )

arrays:
- first elt an operator (i.e., starts with dash or non-alpha char) => rest of array are arguments
- first elt a literal - whole array is just an array.

hashes:
- key an operator => value is its argument
- key a literal => key is a rhs of an infix operator
-- if the value is a hash, then keys of the value hash must be infix ops
--- if the value hash has multiple pairs, then need to join the multiple expressions with the common rhs with a default distributable infix operator (and, or...)
-- if the value is an array, then first elt must be infix op
--- if the infix op is binary (e.g., comparison op), then need to create and join multiple binary expressions with the common rhs using a default distributable infix operator (or, and, ...)
--- if the infix op takes multiple args on lhs (e.g., IN), then rest of array are the arguments

arrayrefs found in arg lists (the cdr of an arrayref) should be interpreted as list args in the compiled code

operator types:
infix binary (comparison ops, incl. =~; IN)
infix distributable (AND, OR, +)
prefix (unary) (NOT)
postfix (unary) (IS NULL, IS NOT NULL)
single argument function (sin(arg))
multi argument function ( extract( v, list | fn(v)) )


* Every item (hash key, hash value, or array element) is either an
  operator or an argument with an associated operator.

{ col => ['val1', 'val2'] } equiv

{ col => [ -or => { '=' => 'val1' }, { '=' => 'val2' } ] } equiv

[ -or, [ '=', col => 'val1'], [ '=', col => 'val2' ] ]
